---
description: 実行環境・パッケージ管理ツールのDenoの説明や利用方針
globs: src/**/*.ts,src/**/*.tsx
alwaysApply: false
---

# Deno説明及び利用方針

## npm互換モード

DenoのNode.js互換APIが使える。また、 `npm:zod` のようにnpmからライブラリを参照することができる。

## 外部ライブラリの使用方法

Deno用のライブラリは多くないので、ユーザーから指定されない限りはNode.js互換APIを優先する。

例外的に、以下のURLはNode.jsよりDeno互換を優先して使用する。

- `jsr:@david/dax` : コマンドランナー
- `jsr:@std/expect` : アサーション
- `jsr:@std/testing` : テストフレームワーク

ライブラリを使用する前にドキュメントを確認する。

- `jsr:` の場合、 `deno doc jsr:@scope/pkgName` でライブラリ基本的なAPIをを確認する
- `npm:` の場合、 `npm-summary pkgName` でライブラリの要約を確認する

また、追加する時には `deno.json` にすでにimportされていないか確認する。存在しない場合、 `deno add ...` で追加する。

## ソースコード内のモジュールの参照方法

自分のディレクトリ以外のソースコードを確認する時は、型定義だけを確認する。

## テストの書き方

`@std/expect` と `@std/testing/bdd` を使う。特に理由がない限り、 `describe` による入れ子はしない。

```typescript
import { expect } from "@std/expect";
import { test } from "@std/testing/bdd";

test("2+3=5", () => {
  expect(add(2, 3), "sum of numbers").toBe(5);
});
```

## アサーションの書き方

`expect(result, "<expected behavior>").toBe("result")` で可能な限り期待する動作を書く。

## モジュール間の依存関係

### importルール

- モジュール間の参照は必ず `mod.ts` を経由
- 他のモジュールのファイルを直接参照してはいけない
- 同一モジュール内のファイルは相対パスで参照
- モジュール内の実装は `deps.ts` からのre-export`を参照

### 依存関係の検証

依存関係の検証には2つの方法がある。

#### 1.コマンドラインでの検証

```sh
deno task check:deps
```

このコマンドは以下をチェックする。

- モジュール間の import が mod.ts を経由しているか
- 他のモジュールのファイルを直接参照していないか

#### 2. リントプラグインによる検証

```sh
deno lint
```

mod-importリントルールが以下をチェックする。

- モジュール間のimportが `mod.ts` を経由しているか
- 違反している場合、修正のヒントを提示

## コード品質の監視

### カバレッジ

カバレッジの取得には `deno task test:cov` を使用する。これは以下のコマンドのエイリアスである。

```sh
deno test --coverage=coverage && deno coverage coverage
``

実行コードと純粋な関数を分離することで、高いカバレッジを維持する。

- 実装（lib.ts）: ロジックを純粋な関数として実装
- エクスポート（mod.ts）: 外部向けインターフェースの定義
- 実行（cli.ts）: エントリーポイントとデバッグコード

### デッドコード解析

- TSR (TypeScript Runtime）を使用してデッドコードを検出
- 未使用のエクスポートや関数を定期的に確認し削除

### 型定義による仕様抽出

- dtsを使用して型定義から自動的にドキュメントを生成
- 型シグネチャに仕様を記述し、dtsとして抽出する
