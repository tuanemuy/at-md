# 実装順序計画

このドキュメントでは、AT-MDプロジェクトの実装順序について詳細に記述します。テスト駆動開発（TDD）の原則に基づき、各モジュールの実装順序とその理由を提供します。

## 1. 実装の基本方針

AT-MDプロジェクトの実装は、以下の基本方針に従って進めます：

1. **内側から外側へ**: ドメインレイヤーから始め、アプリケーションレイヤー、インフラストラクチャレイヤー、そしてプレゼンテーションレイヤーへと進む
2. **テスト駆動開発**: 各モジュールの実装前にテストを作成し、テストが通るように実装を進める
3. **コアドメインの優先**: システムの中核となるコアドメインから実装を開始する
4. **依存関係の最小化**: 外部システムへの依存を最小限に抑え、モックやスタブを活用する
5. **継続的なリファクタリング**: 実装が進むにつれて、コードの品質を維持するためにリファクタリングを行う

## 2. 実装フェーズと順序

### フェーズ1: 基盤構築（2週間）

#### 1.1 プロジェクト構成とインフラストラクチャの設定（並列可能）

- **プロジェクト構造の作成**
  - 理由: 全ての実装の基盤となるため、最初に行う必要がある
  - 成果物: ディレクトリ構造、基本的な設定ファイル

- **開発環境のセットアップ**
  - 理由: 効率的な開発とテストのために必要
  - 成果物: Docker環境、開発用スクリプト

- **CI/CDパイプラインの構築**
  - 理由: 継続的なテストと品質保証のために必要
  - 成果物: GitHub Actions設定

#### 1.2 共通コアモジュールの実装

- **エラー基底クラスの実装**
  - 理由: エラーハンドリング戦略に基づく基本クラスが全レイヤーで必要
  - 成果物: DomainError, ApplicationError, InfrastructureError, PresentationError

- **Result型の実装**
  - 理由: 型安全なエラーハンドリングの基盤として必要
  - 成果物: Result型またはneverthrowライブラリの導入

- **ドメインイベント基盤の実装**
  - 理由: イベント駆動アーキテクチャの基盤として必要
  - 成果物: DomainEvent基底クラス、EventBus

- **ロギング基盤の実装**
  - 理由: エラーログとモニタリングのために必要
  - 成果物: 構造化ロギング機能

### フェーズ2: コアドメイン実装（4週間）

#### 2.1 コンテンツ管理ドメイン（コアドメイン）

- **コンテンツ関連の値オブジェクト実装**
  - 理由: エンティティの構成要素として最初に必要
  - 成果物: ContentMetadata, Version値オブジェクト

- **コンテンツエンティティ実装**
  - 理由: コアドメインの中心的なエンティティ
  - 成果物: Content, Repository エンティティ

- **コンテンツ集約実装**
  - 理由: ドメインロジックの中心となる集約
  - 成果物: ContentAggregate, RepositoryAggregate

- **コンテンツドメインサービス実装**
  - 理由: 複数の集約にまたがるロジックを扱うため
  - 成果物: VersioningService

#### 2.2 配信ドメイン（コアドメイン）

- **配信関連の値オブジェクト実装**
  - 理由: エンティティの構成要素として最初に必要
  - 成果物: PublishStatus, FeedMetadata値オブジェクト

- **配信エンティティ実装**
  - 理由: 配信ドメインの中心的なエンティティ
  - 成果物: Post, Feed エンティティ

- **配信集約実装**
  - 理由: 配信ドメインのドメインロジックを扱う集約
  - 成果物: PostAggregate, FeedAggregate

- **配信ドメインサービス実装**
  - 理由: 複数の集約にまたがるロジックを扱うため
  - 成果物: PublishingService

### フェーズ3: サポートドメイン実装（3週間）

#### 3.1 アカウント管理ドメイン

- **アカウント関連の値オブジェクト実装**
  - 理由: エンティティの構成要素として最初に必要
  - 成果物: Credentials値オブジェクト

- **アカウントエンティティ実装**
  - 理由: アカウント管理の中心的なエンティティ
  - 成果物: User, ATAccount, GitHubIntegration エンティティ

- **アカウント集約実装**
  - 理由: アカウント管理のドメインロジックを扱う集約
  - 成果物: UserAggregate

- **認証サービス実装**
  - 理由: 認証ロジックを扱うドメインサービス
  - 成果物: AuthenticationService

#### 3.2 表示ドメイン

- **表示関連の値オブジェクト実装**
  - 理由: エンティティの構成要素として最初に必要
  - 成果物: PageMetadata, RenderingOptions値オブジェクト

- **表示エンティティ実装**
  - 理由: 表示ドメインの中心的なエンティティ
  - 成果物: Page, ViewTemplate エンティティ

- **表示集約実装**
  - 理由: 表示ドメインのドメインロジックを扱う集約
  - 成果物: PageAggregate

- **レンダリングサービス実装**
  - 理由: マークダウンレンダリングロジックを扱うドメインサービス
  - 成果物: RenderingService

### フェーズ4: アプリケーションレイヤー実装（3週間）

#### 4.1 コンテンツ管理アプリケーションサービス

- **コンテンツリポジトリインターフェース定義**
  - 理由: アプリケーションサービスが依存するインターフェース
  - 成果物: ContentRepository, RepositoryRepository インターフェース

- **コンテンツ関連コマンドハンドラー実装**
  - 理由: ユースケースを実行するコマンドハンドラー
  - 成果物: CreateContentCommandHandler, UpdateContentCommandHandler など

- **コンテンツ関連クエリハンドラー実装**
  - 理由: 読み取りユースケースを実行するクエリハンドラー
  - 成果物: GetContentByIdQueryHandler, ListContentsQueryHandler など

- **コンテンツ同期サービス実装**
  - 理由: GitHubとの同期ロジックを扱うアプリケーションサービス
  - 成果物: ContentSyncService

#### 4.2 配信アプリケーションサービス

- **配信リポジトリインターフェース定義**
  - 理由: アプリケーションサービスが依存するインターフェース
  - 成果物: PostRepository, FeedRepository インターフェース

- **配信関連コマンドハンドラー実装**
  - 理由: ユースケースを実行するコマンドハンドラー
  - 成果物: PublishContentCommandHandler, CreateFeedCommandHandler など

- **配信関連クエリハンドラー実装**
  - 理由: 読み取りユースケースを実行するクエリハンドラー
  - 成果物: GetPostByIdQueryHandler, ListFeedsQueryHandler など

- **フィード同期サービス実装**
  - 理由: AT Protocolとの同期ロジックを扱うアプリケーションサービス
  - 成果物: FeedSyncService

#### 4.3 アカウント管理アプリケーションサービス

- **ユーザーリポジトリインターフェース定義**
  - 理由: アプリケーションサービスが依存するインターフェース
  - 成果物: UserRepository インターフェース

- **認証関連コマンドハンドラー実装**
  - 理由: 認証ユースケースを実行するコマンドハンドラー
  - 成果物: SignInCommandHandler, ConnectATAccountCommandHandler など

- **ユーザー関連クエリハンドラー実装**
  - 理由: ユーザー情報取得ユースケースを実行するクエリハンドラー
  - 成果物: GetUserProfileQueryHandler など

#### 4.4 表示アプリケーションサービス

- **ページリポジトリインターフェース定義**
  - 理由: アプリケーションサービスが依存するインターフェース
  - 成果物: PageRepository, TemplateRepository インターフェース

- **ページ関連コマンドハンドラー実装**
  - 理由: ページ管理ユースケースを実行するコマンドハンドラー
  - 成果物: UpdatePageCommandHandler など

- **ページ関連クエリハンドラー実装**
  - 理由: ページ取得ユースケースを実行するクエリハンドラー
  - 成果物: GetPageBySlugQueryHandler など

- **ページ構成サービス実装**
  - 理由: ページ構成ロジックを扱うアプリケーションサービス
  - 成果物: PageCompositionService

### フェーズ5: インフラストラクチャレイヤー実装（4週間）

#### 5.1 データベース関連実装

- **データベーススキーマ実装**
  - 理由: データ永続化の基盤として必要
  - 成果物: Drizzle ORM スキーマ定義

- **マイグレーション実装**
  - 理由: データベーススキーマの進化を管理するため
  - 成果物: マイグレーションスクリプト

- **リポジトリ実装**
  - 理由: ドメインオブジェクトの永続化を行うため
  - 成果物: DrizzleContentRepository, DrizzleUserRepository など

#### 5.2 外部サービス連携実装

- **GitHub API アダプター実装**
  - 理由: GitHubとの連携を行うため
  - 成果物: GitHubApiAdapter

- **AT Protocol アダプター実装**
  - 理由: AT Protocolとの連携を行うため
  - 成果物: ATProtocolAdapter

- **サーキットブレーカー実装**
  - 理由: 外部サービス障害時の対応として必要
  - 成果物: CircuitBreaker

- **リトライ機能実装**
  - 理由: 一時的な障害に対応するため
  - 成果物: withRetry関数

#### 5.3 イベント処理実装

- **イベントバス実装**
  - 理由: ドメインイベントの配信基盤として必要
  - 成果物: EventBus実装

- **イベントハンドラー実装**
  - 理由: ドメインイベントに反応して処理を行うため
  - 成果物: ContentPublishedHandler など

- **イベント永続化実装**
  - 理由: イベントの永続化と再生のため
  - 成果物: EventStore

### フェーズ6: プレゼンテーションレイヤー実装（4週間）

#### 6.1 API実装

- **Honoミドルウェア実装**
  - 理由: API共通処理として必要
  - 成果物: 認証ミドルウェア、エラーハンドリングミドルウェアなど

- **APIルート実装**
  - 理由: クライアントからのリクエストを処理するため
  - 成果物: コンテンツAPI、ユーザーAPI、配信APIなど

- **バリデーション実装**
  - 理由: 入力データの検証を行うため
  - 成果物: Zodスキーマ定義

#### 6.2 サーバーアクション実装

- **認証関連サーバーアクション**
  - 理由: ユーザー認証処理を行うため
  - 成果物: signIn, signOut サーバーアクション

- **コンテンツ関連サーバーアクション**
  - 理由: コンテンツ管理処理を行うため
  - 成果物: createContent, updateContent サーバーアクション

- **配信関連サーバーアクション**
  - 理由: コンテンツ配信処理を行うため
  - 成果物: publishContent サーバーアクション

#### 6.3 UI実装

- **共通UIコンポーネント実装**
  - 理由: 一貫したUIを提供するため
  - 成果物: shadcn/uiコンポーネント設定

- **レイアウトコンポーネント実装**
  - 理由: アプリケーション全体のレイアウトを定義するため
  - 成果物: ヘッダー、フッター、サイドバーなど

- **ページコンポーネント実装**
  - 理由: 各機能のUIを提供するため
  - 成果物: ダッシュボード、コンテンツ編集、設定ページなど

- **マークダウンレンダリングコンポーネント実装**
  - 理由: マークダウンコンテンツの表示を行うため
  - 成果物: MDXコンポーネント、Mermaid.js連携など

### フェーズ7: サーバーレス関数実装（2週間）

- **GitHub同期関数実装**
  - 理由: GitHubからのWebhookを処理するため
  - 成果物: GitHubSyncFunction

- **フィード同期関数実装**
  - 理由: AT Protocolからの通知を処理するため
  - 成果物: FeedSyncFunction

- **バックグラウンドジョブ実装**
  - 理由: 定期的なタスクを実行するため
  - 成果物: 定期同期ジョブなど

### フェーズ8: 統合テストと最適化（2週間）

- **E2Eテスト実装**
  - 理由: システム全体の動作を検証するため
  - 成果物: Playwrightテスト

- **パフォーマンス最適化**
  - 理由: システムのレスポンス時間を改善するため
  - 成果物: キャッシュ戦略、クエリ最適化など

- **セキュリティレビュー**
  - 理由: セキュリティ脆弱性を検出・修正するため
  - 成果物: セキュリティ対策実装

## 3. 並列開発の可能性

以下の領域では、並列開発が可能です：

1. **ドメインレイヤー**
   - コンテンツ管理ドメインと配信ドメインは比較的独立しているため、並列開発可能
   - アカウント管理ドメインと表示ドメインも並列開発可能

2. **アプリケーションレイヤー**
   - 各ドメインのアプリケーションサービスは、対応するドメインレイヤーが完成した後に並列開発可能

3. **インフラストラクチャレイヤー**
   - データベース関連実装と外部サービス連携実装は並列開発可能
   - ただし、リポジトリ実装はデータベーススキーマに依存するため、スキーマ定義後に実施

4. **プレゼンテーションレイヤー**
   - API実装とUI実装は並列開発可能
   - ただし、UI実装はAPIが完成していると効率的

## 4. 依存関係と優先順位

実装順序を決定する際の主な依存関係は以下の通りです：

1. **垂直方向の依存関係**
   - プレゼンテーションレイヤー → アプリケーションレイヤー → ドメインレイヤー
   - インフラストラクチャレイヤー → アプリケーションレイヤー（リポジトリインターフェース）

2. **水平方向の依存関係**
   - コンテンツ管理ドメイン → 配信ドメイン（コンテンツが配信の入力となる）
   - アカウント管理ドメイン → 他のすべてのドメイン（認証・認可）

優先順位の決定基準：

1. **コアドメイン優先**: システムの中核となるコンテンツ管理と配信ドメインを優先
2. **依存関係の少ないものから**: 他のモジュールへの依存が少ないものから実装
3. **ユーザー価値の高いものから**: ユーザーに価値を提供する機能を優先

## 5. リスク管理

実装中に発生する可能性のあるリスクと対策：

1. **外部APIの仕様変更**
   - 対策: アダプターパターンの徹底、モックを活用した開発

2. **要件の変更**
   - 対策: ドメインモデルの堅牢な設計、変更に強いアーキテクチャ

3. **技術的な障害**
   - 対策: 早期からのプロトタイピング、リスクの高い部分の先行実装

4. **チーム間の連携不足**
   - 対策: 定期的な進捗共有、ペアプログラミング

## 6. 実装スケジュール

全体の実装期間は約24週間（6ヶ月）を想定しています。

| フェーズ | 期間 | 主な成果物 |
|---------|------|-----------|
| 1. 基盤構築 | 2週間 | プロジェクト構造、共通コアモジュール |
| 2. コアドメイン実装 | 4週間 | コンテンツ管理・配信ドメイン |
| 3. サポートドメイン実装 | 3週間 | アカウント管理・表示ドメイン |
| 4. アプリケーションレイヤー実装 | 3週間 | コマンド/クエリハンドラー、アプリケーションサービス |
| 5. インフラストラクチャレイヤー実装 | 4週間 | リポジトリ、外部サービスアダプター |
| 6. プレゼンテーションレイヤー実装 | 4週間 | API、UI |
| 7. サーバーレス関数実装 | 2週間 | Webhook処理、バックグラウンドジョブ |
| 8. 統合テストと最適化 | 2週間 | E2Eテスト、パフォーマンス最適化 |

## 7. まとめ

AT-MDプロジェクトの実装は、ドメイン駆動設計の原則に従い、内側から外側へと進めていきます。コアドメインから始め、アプリケーションレイヤー、インフラストラクチャレイヤー、そしてプレゼンテーションレイヤーへと実装を進めることで、堅牢で保守性の高いシステムを構築します。

テスト駆動開発の実践により、各モジュールの品質を確保しながら実装を進めることができます。また、並列開発の可能性を活かすことで、効率的な開発を実現します。

この実装順序計画に従うことで、AT-MDプロジェクトは体系的かつ効率的に実装され、高品質なシステムとして完成することが期待されます。 